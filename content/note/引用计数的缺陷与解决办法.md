---
title: 引用计数的缺陷与解决办法
author: Xin Lu
date: '2023-05-04'
slug: []
categories: []
tags: []
---

*Python* 内部采用 **引用计数法** ，为每个对象维护引用次数，并据此回收不再需要的垃圾对象。由于引用计数法存在重大缺陷，循环引用时有内存泄露风险，因此 *Python* 还采用 **标记清除法** 来回收存在循环引用的垃圾对象。此外，为了提高垃圾回收( *GC* )效率，*Python* 还引入了 **分代回收机制** 。

由于内部循环引用的存在，就算我们将外部变量删除，对象的引用计数也不为零，无法回收：

这个问题可就严重了，该回收的对象无法回收，不就内存泄露了吗？

那么，如何解决循环引用带来的问题呢？解决问题的思路主要有两个：

- 精心设计程序，确保对象不会形成环状引用关系(被动避免)；
- 实现算法定期检查识别需要回收的垃圾对象，进而将它们回收(主动回收)；

*Python* 先通过一个算法找出根对象，然后再从根对象出发遍历可达的活跃对象。

第一步需要找出 **根对象** ( *root object* )集合。所谓根对象，就是指被全局引用或者在栈中引用的对象，这部对象是不能被删除的。因此，我们将这部分对象标记为绿色，作为活跃对象遍历的起点。

这样一来，当我们遍历完所有根对象，活跃对象也就全部找出来了：

根对象本身是 **可达的** ( *reachable* )，不能删除；被根对象引用的对象也是可达的，同样不能删除；以此类推。我们从一个根对象出发，沿着引用关系遍历，遍历到的所有对象都是可达的，不能删除。

而没有被标色的对象就是 **不可达** ( *unreachable* )的垃圾对象，可以被安全回收。循环引用的致命缺陷完美解决了！

*_PyObject_GC_Alloc* 自增 *count* 后如果超过阀值( *700* )，将调用 *collect_generations* 执行一次垃圾回收( *GC* )。

- 每新增 *701* 个需要 *GC* 的对象，触发一次新生代 *GC* ；
- 每执行 *11* 次新生代 *GC* ，触发一次中生代 *GC* ；
- 每执行 *11* 次中生代 *GC* ，触发一次老生代 *GC* (老生代 *GC* 还受其他策略影响，频率更低)；
- 执行某个生代 *GC* 前，年轻生代对象链表也移入该代，一起 *GC* ；
- 一个对象创建后，随着时间推移将被逐步移入老生代，回收频率逐渐降低；